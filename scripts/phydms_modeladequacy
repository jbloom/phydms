#!python

"""Model Adequacy test with ``phydms``.

Written by Sarah Hilton."""

import multiprocessing
import phydmslib.simulate
import phydmslib.file_io
import phydmslib.modeladequacy
from phydmslib.constants import *
import os
import subprocess
import scipy
import numpy as np
import itertools
import pandas as pd
import logging
import phydmslib.parsearguments
import glob
import time


def RunCmds(cmds):
    """Runs the command line arguments in *cmds* using *subprocess*."""
    try:
        p = subprocess.Popen(cmds, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        pid = p.pid
        (stdout, stderr) = p.communicate()
    except:
        os.kill(pid, signal.SIGTERM)


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSAdequacyParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # set up
    amino_acids = list(INDEX_TO_AA.values())
    amino_acids.sort()

    # setup files
    # file names slightly different depending on
    # whether outprefix is directory or file
    if args['outprefix'][-1] == '/':
        logfile = "{0}log.log".format(args['outprefix'])
    else:
        logfile = "{0}.log".format(args['outprefix'])
        args['outprefix'] = '{0}_'.format(args['outprefix'])
    pvaluesfile = '{0}pvalues.csv'.format(args['outprefix'])
    raxmlStandardOutputFile = '{0}raxml_output.txt'.format(args['outprefix'])
    phydmsStandardOutputFile = '{0}phydms_output.txt'.format(args['outprefix'])

    # Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
                        level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # set the random seed
    seed = int(args["seed"])
    scipy.random.seed(seed)
    np.random.seed(seed)

    # print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'
                .format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    logger.info('Parsed the following command-line arguments:\n{0}\n'
                .format('\n'.join(['\t{0} = {1}'.format(key, args[key])
                        for key in args.keys()])))

    # check to make sure only ExpCM or YNGKP_M0 model
    if args["model"] == "YNGKP_M0":
        model = args["model"]
        model_type = "YNGKP_M0"
    elif (args["model"][0] == "ExpCM"):
        model = "{0}_{1}".format(args["model"][0], args["model"][1])
        model_type = "ExpCM"
        prefs = phydmslib.file_io.readPrefs(args["model"][1],
                                            minpref=args["minpref"])
        prefs = [prefs[r] for r in sorted(prefs.keys())]
    else:
        raise ValueError("Model must be YNKP_M0 or ExpCM not {0}"
                         .format(args["model"]))

    # check alignment
    alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
                                                     checknewickvalid=True)
    logger.info(('Starting analaysis to assess the adequacy of model {0} for'
                'alignment {1}'.format(model, args['alignment'])))
    logger.info('{0} is a valid alignment specifying {1} sequences of length {2}.\n'
                .format(args["alignment"], len(alignment), len(alignment[0][1])))

    # read or build a tree
    if args["tree"]:
        logger.info("Reading tree from {0}".format(args['tree']))
    else:
        logger.info("Tree not specified.")
        try:
            raxmlversion = subprocess.check_output([args['raxml'], '-v'],
                                                   stderr=subprocess.STDOUT)\
                                                   .strip()
            logger.info("Inferring tree with RAxML using command {0}"
                        .format(args['raxml']))

            # remove pre-existing RAxML files
            cwd = os.getcwd()
            full_path = os.path.join(cwd, args["outprefix"])
            raxmlOutputName = os.path.splitext(os.path.basename(
                    args["alignment"]))[0]
            raxmlOutputFiles = []
            for raxmlFile in glob.glob("{0}/RAxML_*{1}".format(full_path, raxmlOutputName)):
                if os.path.isfile(raxmlFile):
                    raxmlOutputFiles.append(raxmlFile)
                    os.remove(raxmlFile)
            if len(raxmlOutputFiles) > 0:
                logger.info('Removed the following RAxML files:\n{0}\n'
                            .format('\n'.join(['\t{0}'.format(fname) for
                                               fname in raxmlOutputFiles])))
            # run RAxmL
            raxmlCMD = [args['raxml'], '-s', args['alignment'], '-n',
                        raxmlOutputName, '-m', 'GTRCAT', '-w', full_path,
                        '-p1', '-T', '2']
            with open(raxmlStandardOutputFile, 'w') as f:
                subprocess.check_call(raxmlCMD, stdout=f)

            # move RAxML tree to output directory and remove all other files
            for raxmlFile in glob.glob("{0}RAxML_*{1}".format(full_path, raxmlOutputName)):
                if "bestTree" in raxmlFile:
                    args["tree"] = args["outprefix"] + 'RAxML_tree.newick'
                    os.rename(raxmlFile, args['tree'])
                    logger.info("RAxML inferred tree is now named {0}\n"
                                .format(args['tree']))
                else:
                    os.remove(raxmlFile)
        except OSError:
            raise ValueError("The raxml command of {0} is not valid. Is raxml"
                             " installed at this path?".format(args['raxml']))

    # run `phydms` to fit the model
    modelparams = "{0}phydms_modelparams.txt".format(args["outprefix"])
    phydms_CMD = ["phydms", args["alignment"], args["tree"],
                  model, "{0}{1}".format(args["outprefix"], "phydms"),
                  "--minpref", "{0}".format(args["minpref"])]
    logger.info('Starting phydms command: {0}'.format(" ".join(phydms_CMD)))
    RunCmds(phydms_CMD)
    assert os.path.isfile(modelparams), "Could not find model params file"
    with open(modelparams, 'r') as f:
        params = f.read()
    logger.info('phydms run complete. Optimized parameters ({0}) are\n{1}\n'
                .format(modelparams, params))

    # set up cpus
    logger.info('Starting simulations.')
    logger.info('Performing {0} replicate simulations.'
                .format(args["number_simulations"]))
    ncpus, msg = phydmslib.modeladequacy.calc_ncpus(args['ncpus'],
                                                    args["number_simulations"])
    logger.info(msg)

    # build model
    if model_type == "ExpCM":
        model = phydmslib.modeladequacy.make_expcm(modelparams, prefs)
    elif model_type == "YNGKP_M0":
        nsites = int(len(alignment[0][1]) / 3)
        model = phydmslib.modeladequacy.make_YNGKP_M0(modelparams, nsites)
    else:
        raise ValueError("Unexpected model type of {0}".format(model_type))

    # read in tree
    tree = Bio.Phylo.read(args["tree"], 'newick')
    for node in tree.get_terminals() + tree.get_nonterminals():
        if (node.branch_length is None) and (node == tree.root):
            node.branch_length = 1e-06

    # run the simulations
    sims = phydmslib.modeladequacy.run_simulations(tree, model,
                                                   args['number_simulations'],
                                                   seed, ncpus)

    # process the simulations
    sims_by_site = phydmslib.modeladequacy.process_simulations(sims,
                                                               model.nsites)

    # calculate distances and p values
    logger.info('Calculating p values.')
    pvalues = phydmslib.modeladequacy.calc_distances_pvalues(sims_by_site,
                                                             model,
                                                             alignment,
                                                             seed)

    # calculate q values
    pvalues = phydmslib.modeladequacy.calc_qvalues(pvalues)
    pvalues.to_csv(pvaluesfile, index=False)
    logger.info('P values in {0}.'.format(pvaluesfile))

    logger.info('Successful completion of model adequacy test.')


if __name__ == '__main__':
    main()  # run the script
