#!python

"""Model Adequacy test with ``phydms``.

Written by Sarah Hilton."""

# from multiprocessing import Pool
import multiprocessing
import phydmslib.simulate
import phydmslib.file_io
import phydmslib.modeladequacy
from phydmslib.constants import *
import os
from statsmodels.sandbox.stats.multicomp import multipletests
import subprocess
import scipy
import numpy as np
import itertools
import pandas as pd
import logging
import phydmslib.parsearguments
import glob
import time


def runSimulator(simulator, seed_list, i, return_dict):
    """Runs `simulator.simulate` for a list of seeds"""
    seed_list = [int(x) for x in seed_list]
    simulations = list(map(simulator.simulate, seed_list))
    return_dict[i] = simulations


def RunCmds(cmds):
    """Runs the command line arguments in *cmds* using *subprocess*."""
    try:
        p = subprocess.Popen(cmds, stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        pid = p.pid
        (stdout, stderr) = p.communicate()
    except:
        os.kill(pid, signal.SIGTERM)


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSAdequacyParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # set up
    amino_acids = list(INDEX_TO_AA.values())
    amino_acids.sort()
    metrics = ["JensenShannon", "half_sum_abs_diff", "RMSD"]

    # setup files
    # file names slightly different depending on
    # whether outprefix is directory or file
    if args['outprefix'][-1] == '/':
        logfile = "{0}log.log".format(args['outprefix'])
    else:
        logfile = "{0}.log".format(args['outprefix'])
        args['outprefix'] = '{0}_'.format(args['outprefix'])
    pvaluesfile = '{0}pvalues.csv'.format(args['outprefix'])
    raxmlStandardOutputFile = '{0}raxml_output.txt'.format(args['outprefix'])
    phydmsStandardOutputFile = '{0}phydms_output.txt'.format(args['outprefix'])

    # Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
                        level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # set the random seed
    seed = int(args["seed"])
    scipy.random.seed(seed)
    np.random.seed(seed)

    # print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'
                .format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    logger.info('Parsed the following command-line arguments:\n{0}\n'
                .format('\n'.join(['\t{0} = {1}'.format(key, args[key])
                        for key in args.keys()])))

    # check to make sure only ExpCM or YNGKP_M0 model
    if args["model"] == "YNGKP_M0":
        model = args["model"]
        model_type = "YNGKP_M0"
    elif (args["model"][0] == "ExpCM"):
        model = "{0}_{1}".format(args["model"][0], args["model"][1])
        model_type = "ExpCM"
        prefs = phydmslib.file_io.readPrefs(args["model"][1])
        prefs = [prefs[r] for r in sorted(prefs.keys())]
    else:
        raise ValueError("Model must be YNKP_M0 or ExpCM not {0}"
                         .format(args["model"]))

    # check alignment
    alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
                                                     checknewickvalid=True)
    logger.info(('Starting analaysis to assess the adequacy of model {0} for'
                'alignment {1}'.format(model, args['alignment'])))
    logger.info('{0} is a valid alignment specifying {1} sequences of length {2}.\n'
                .format(args["alignment"], len(alignment), len(alignment[0][1])))

    # calc alignment frequencies
    alignment_freqs = phydmslib.modeladequacy.calc_aa_frequencies(alignment)
    alignment_freqs["alignment"] = (alignment_freqs[amino_acids]
                                    .apply(lambda r: tuple(r), axis=1)
                                    .apply(scipy.array))
    alignment_freqs = scipy.array(alignment_freqs["alignment"].tolist())

    # read or build a tree
    if args["tree"]:
        logger.info("Reading tree from {0}".format(args['tree']))
    else:
        logger.info("Tree not specified.")
        try:
            raxmlversion = subprocess.check_output([args['raxml'], '-v'],
                                                   stderr=subprocess.STDOUT)\
                                                   .strip()
            logger.info("Inferring tree with RAxML using command {0}"
                        .format(args['raxml']))

            # remove pre-existing RAxML files
            cwd = os.getcwd()
            full_path = os.path.join(cwd, args["outprefix"])
            raxmlOutputName = os.path.splitext(os.path.basename(
                    args["alignment"]))[0]
            raxmlOutputFiles = []
            for raxmlFile in glob.glob("{0}/RAxML_*{1}".format(full_path, raxmlOutputName)):
                if os.path.isfile(raxmlFile):
                    raxmlOutputFiles.append(raxmlFile)
                    os.remove(raxmlFile)
            if len(raxmlOutputFiles) > 0:
                logger.info('Removed the following RAxML files:\n{0}\n'
                            .format('\n'.join(['\t{0}'.format(fname) for
                                               fname in raxmlOutputFiles])))
            # run RAxmL
            raxmlCMD = [args['raxml'], '-s', args['alignment'], '-n',
                        raxmlOutputName, '-m', 'GTRCAT', '-w', full_path,
                        '-p1', '-T', '2']
            with open(raxmlStandardOutputFile, 'w') as f:
                subprocess.check_call(raxmlCMD, stdout=f)

            # move RAxML tree to output directory and remove all other files
            for raxmlFile in glob.glob("{0}RAxML_*{1}".format(full_path, raxmlOutputName)):
                if "bestTree" in raxmlFile:
                    args["tree"] = args["outprefix"] + 'RAxML_tree.newick'
                    os.rename(raxmlFile, args['tree'])
                    logger.info("RAxML inferred tree is now named {0}\n"
                                .format(args['tree']))
                else:
                    os.remove(raxmlFile)
        except OSError:
            raise ValueError("The raxml command of {0} is not valid. Is raxml"
                             " installed at this path?".format(args['raxml']))

    # run `phydms` to fit the model
    modelparams = "{0}phydms_modelparams.txt".format(args["outprefix"])
    phydms_CMD = ["phydms", args["alignment"], args["tree"],
                  model, "{0}{1}".format(args["outprefix"], "phydms")]
    logger.info('Starting phydms command: {0}'.format(" ".join(phydms_CMD)))
    RunCmds(phydms_CMD)
    assert os.path.isfile(modelparams), "Could not find model params file"
    with open(modelparams, 'r') as f:
        params = f.read()
    logger.info('phydms run complete. Optimized parameters ({0}) are\n{1}\n'
                .format(modelparams, params))

    # set up cpus
    logger.info('Starting simulations.')
    logger.info('Performing {0} replicate simulations.'
                .format(args["number_simulations"]))
    min_sims_per_cpu = 1000
    if args['ncpus'] == -1:
        ncpus = multiprocessing.cpu_count()
    else:
        ncpus = args['ncpus']
    assert ncpus >= 1, "{0} CPUs specified".format(ncpus)
    if (args["number_simulations"]/ncpus) < min_sims_per_cpu:
        ncpus = max(1, args["number_simulations"] // min_sims_per_cpu)
        logger.info('Using {0} CPU(s) to ensure >= {1} simulations / CPU'
                    .format(ncpus, min_sims_per_cpu))
    else:
        logger.info('Using {0} CPUs.'.format(ncpus))

    # build model
    if model_type == "ExpCM":
        model = phydmslib.modeladequacy.make_expcm(modelparams, prefs)
    elif model_type == "YNGKP_M0":
        nsites = int(len(alignment[0][1]) / 3)
        model = phydmslib.modeladequacy.make_YNGKP_M0(modelparams, nsites)
    else:
        raise ValueError("Unexpected model type of {0}".format(model_type))

    # stationary state frequencies
    ss_freqs = phydmslib.modeladequacy.calc_stationary_state_freqs(model)

    # read in tree
    tree = Bio.Phylo.read(args["tree"], 'newick')
    for node in tree.get_terminals() + tree.get_nonterminals():
        if (node.branch_length is None) and (node == tree.root):
            node.branch_length = 1e-06

    # build the simulator object
    simulator = phydmslib.simulate.Simulator(tree, model)
    seeds = [seed+i for i in range(args["number_simulations"])]

    # run the simulations
    if ncpus == 1:
        simulations = map(simulator.simulate, seeds)
        simulations = list(simulations)
    elif ncpus > 1:  # use multiprocessing
        manager = multiprocessing.Manager()
        simulations = manager.dict()
        seed_batches = scipy.array_split(seeds, ncpus)
        assert len(seed_batches) == ncpus
        processes = []
        for i, seed_batch in enumerate(seed_batches):
            p = multiprocessing.Process(target=runSimulator, args=(simulator,
                                                                   seed_batch,
                                                                   i,
                                                                   simulations))
            processes.append(p)
            p.start()
        for process in processes:
            process.join()
        simulations = simulations.values()
        simulations = list(itertools.chain.from_iterable(simulations))
    else:
        raise ValueError("Unexpected number of cpus ({0})".format(ncpus))
    assert len(simulations) == args['number_simulations']

    # process the simulations
    simulations_by_site = [[] for x in range(model.nsites)]
    for rep in simulations:
        sim_freqs = phydmslib.modeladequacy.calc_aa_frequencies(rep)
        sim_freqs = sim_freqs[amino_acids].values
        for site in range(model.nsites):
            simulations_by_site[site].append(sim_freqs[site])

    # calculate distances and p values
    logger.info('Calculating p values.')
    pvalues = []
    for site in range(model.nsites):
        sims = simulations_by_site[site]
        ss = ss_freqs[site]
        natural = alignment_freqs[site]
        for metric in metrics:
            # distance from model to simulations
            sim = scipy.array([phydmslib.modeladequacy.prefDistance(sim, ss, metric, check_input=False)
                               for sim in sims])
            # distance from model to natural alignment
            natural_distance = phydmslib.modeladequacy.prefDistance(natural,
                                                                    ss,
                                                                    metric,
                                                                    check_input=False)
            pvalue = phydmslib.modeladequacy.calculate_pvalue(sim,
                                                              natural_distance,
                                                              seed=seed + site)
            pvalues.append((site+1, pvalue, metric))
    pvalues = pd.DataFrame(pvalues, columns=['site', 'pvalue', 'metric'])

    # calculate q values
    final = []
    for name, group in pvalues.groupby("metric"):
        group = group.sort_values(by="pvalue", ascending=True)
        group["qvalue"] = multipletests(group["pvalue"].tolist(),
                                        method='fdr_bh')[1]
        final.append(group)
    pd.concat(final).to_csv(pvaluesfile, index=False)
    logger.info('P values in {0}.'.format(pvaluesfile))

    logger.info('Successful completion of model adequacy test.')


if __name__ == '__main__':
    main()  # run the script
